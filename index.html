<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <title>AI RESCUE FORCE: H·ª®NG D·ªÆ LI·ªÜU</title>
    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.5.1/dist/confetti.browser.min.js"></script>
    <style>
        :root { --main: #00f2ff; --accent: #bc13fe; --danger: #ff0055; --success: #2ecc71; --bg-dark: #050a10; }
        body { font-family: 'Segoe UI', sans-serif; background: var(--bg-dark); color: #fff; display: flex; justify-content: center; align-items: center; height: 100vh; margin: 0; overflow: hidden; user-select: none; cursor: none; }
        
        #game-area { background: linear-gradient(to bottom, #0d1a2a, #050a10); border: 2px solid var(--main); width: 90%; max-width: 800px; height: 90vh; max-height: 600px; position: relative; overflow: hidden; border-radius: 15px; box-shadow: 0 0 20px var(--main), inset 0 0 10px var(--main); }
        
        #player-robot { position: absolute; bottom: 10px; width: 80px; height: 80px; background: rgba(0, 242, 255, 0.2); border: 2px solid var(--main); border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 40px; left: 50%; transform: translateX(-50%); transition: left 0.1s linear; z-index: 10; cursor: grab; box-shadow: 0 0 15px var(--main); }
        
        .falling-data { position: absolute; top: -50px; width: 120px; height: 40px; background: #333; border: 2px solid #555; border-radius: 5px; display: flex; align-items: center; justify-content: center; font-size: 14px; text-align: center; color: white; transition: background 0.1s; z-index: 5; box-shadow: 0 0 5px rgba(255,255,255,0.2); }
        .falling-data.correct { background: var(--success); border-color: var(--success); box-shadow: 0 0 10px var(--success); }
        .falling-data.wrong { background: var(--danger); border-color: var(--danger); box-shadow: 0 0 10px var(--danger); }
        
        #question-box { position: absolute; top: 20px; left: 50%; transform: translateX(-50%); width: 80%; padding: 15px; background: rgba(0,0,0,0.8); border: 1px solid var(--accent); border-radius: 8px; text-align: center; font-size: 18px; font-weight: bold; color: var(--accent); z-index: 20; box-shadow: 0 0 10px var(--accent); }
        
        #score-display { position: absolute; top: 10px; left: 10px; font-size: 20px; font-weight: bold; color: var(--main); z-index: 20; text-shadow: 0 0 5px var(--main); }
        
        /* Login/Final Screen */
        .game-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); z-index: 30; display: flex; flex-direction: column; justify-content: center; align-items: center; text-align: center; }
        .game-overlay input { padding: 12px; border-radius: 5px; border: 1px solid var(--main); background: #000; color: var(--main); width: 80%; max-width: 300px; margin-bottom: 15px; text-align: center; box-shadow: 0 0 5px var(--main); }
        .game-overlay button { background: var(--main); color: #000; border: none; padding: 12px 30px; border-radius: 5px; cursor: pointer; font-weight: bold; box-shadow: 0 0 15px var(--main); margin-top: 10px; }
        .game-overlay h1 { color: var(--main); text-shadow: 0 0 10px var(--main); }
        .game-overlay .message { color: #aaa; margin-bottom: 20px; }
        
        .screen-shake-anim { animation: shake 0.2s cubic-bezier(.36,.07,.19,.97) both; }
        @keyframes shake { 10%, 90% { transform: translate3d(-1px, 0, 0); } 20%, 80% { transform: translate3d(2px, 0, 0); } 30%, 50%, 70% { transform: translate3d(-4px, 0, 0); } 40%, 60% { transform: translate3d(4px, 0, 0); } }
        
        .hit-effect { background-color: var(--danger) !important; box-shadow: 0 0 20px var(--danger) !important; animation: hitFlash 0.3s forwards; }
        @keyframes hitFlash { 0% { opacity: 1; } 100% { opacity: 0; } }
        
        #final-score { font-size: 40px; font-weight: bold; color: var(--success); text-shadow: 0 0 15px var(--success); }
        #final-rank { font-size: 24px; color: var(--accent); margin-top: 10px; }
    </style>
</head>
<body>

<div id="game-area">
    <div id="score-display">ƒêI·ªÇM: <span id="current-score">0</span></div>
    <div id="question-box">Loading Question...</div>
    <div id="player-robot">ü§ñ</div>

    <div id="login-screen" class="game-overlay">
        <div style="font-size: 60px; color: var(--main); text-shadow: 0 0 20px var(--main);">ü§ñ</div>
        <h1>AI RESCUE FORCE</h1>
        <p class="message">Robot Bi-A ƒëang c·∫ßn d·ªØ li·ªáu chu·∫©n ƒë·ªÉ ho·∫°t ƒë·ªông.<br>H√£y gi√∫p n√≥ h·ª©ng ƒë√∫ng d·ªØ li·ªáu.</p>
        <input type="text" id="p-name" placeholder="T√äN PHI C√îNG" required><br>
        <input type="text" id="p-class" placeholder="M√É ƒê∆†N V·ªä (L·ªöP)" required><br>
        <button onclick="startGame()">KH·ªûI ƒê·ªòNG NHI·ªÜM V·ª§</button>
    </div>

    <div id="final-screen" class="game-overlay" style="display: none;">
        <div style="font-size: 60px;">üèÜ</div>
        <h1>NHI·ªÜM V·ª§ HO√ÄN TH√ÄNH!</h1>
        <p class="message" id="final-message"></p>
        <div id="final-rank"></div>
        <div id="final-score"></div>
        <p style="color: #45a247;">‚úÖ D·ªØ li·ªáu ƒë√£ ƒë∆∞·ª£c ƒë·ªìng b·ªô.</p>
        <button onclick="location.reload()">B·∫ÆT ƒê·∫¶U NHI·ªÜM V·ª§ M·ªöI</button>
    </div>
</div>

<iframe name="hidden_iframe" id="hidden_iframe" style="display:none;"></iframe>

<script>
    const CONFIG_FORM = {
        formAction: "https://docs.google.com/forms/d/e/1FAIpQLSda4kGylYwxOjVrfn9VRXVgHqtjg2QhH3KvXYrZKSCrjB3zjQ/formResponse",
        entryName: "entry.2038111055",
        entryClass: "entry.1611801759",
        entryScore: "entry.1076541849"
    };

    const questions = [
        { q: "ƒê·ªÉ AI nh·∫≠n di·ªán 'M·∫∑t c∆∞·ªùi' ch√≠nh x√°c, b·∫°n kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ l·∫´n 'M·∫∑t bu·ªìn' v√†o. ƒê√¢y l√† ti√™u chu·∫©n n√†o?", a: ["ƒê√∫ng (Accuracy)", "ƒê·ªß", "ƒêa d·∫°ng", "ƒê·∫Øt"], c: 0 },
        { q: "AI ch·ªâ h·ªçc ƒë∆∞·ª£c ·∫£nh c·ªßa 1 b·∫°n trong nh√≥m n√™n kh√¥ng nh·∫≠n di·ªán ƒë∆∞·ª£c c√°c b·∫°n kh√°c. ƒê√¢y l√† l·ªói g√¨?", a: ["L·ªói ph·∫ßn c·ª©ng", "L·ªách (Bias)", "H·∫øt b·ªô nh·ªõ", "Virus"], c: 1 },
        { q: "C√¢u n√≥i 'Garbage In - Garbage Out' nh·∫Øc nh·ªü ƒëi·ªÅu g√¨?", a: ["AI t·ª± d·ªçn r√°c", "D·ªØ li·ªáu r√°c cho k·∫øt qu·∫£ r√°c", "M√°y t√≠nh b·ªã h·ªèng", "C·∫ßn qu√©t d·ªçn ph√≤ng m√°y"], c: 1 },
        { q: "C·∫ßn ch·ª•p ·∫£nh m·∫∑t ·ªü nhi·ªÅu g√≥c (tr√°i, ph·∫£i, th·∫≥ng) ƒë·ªÉ ƒë·∫£m b·∫£o ti√™u chu·∫©n n√†o?", a: ["ƒê√∫ng", "ƒê·ªß", "ƒêa d·∫°ng (Diversity)", "ƒê·∫πp"], c: 2 },
        { q: "M·ªói nh√£n c·∫£m x√∫c c·∫ßn t·ªëi thi·ªÉu bao nhi√™u m·∫´u ·∫£nh ƒë·ªÉ m√°y h·ªçc t·ªët?", a: ["1 t·∫•m", "5 t·∫•m", "15-20 t·∫•m", "1000 t·∫•m"], c: 2 },
        { q: "Khi AI ƒëo√°n sai, ta c·∫ßn quay l·∫°i ki·ªÉm tra ·∫£nh hu·∫•n luy·ªán. B∆∞·ªõc n√†y g·ªçi l√† g√¨?", a: ["X√≥a m√°y", "Truy v·∫øt ngu·ªìn l·ªói", "Ch·ª•p ·∫£nh l·∫°i", "N√¢ng c·∫•p RAM"], c: 1 },
        { q: "ƒê·ªÉ m√°y kh√¥ng b·ªã 'L·ªách' (Bias), s·ªë l∆∞·ª£ng ·∫£nh gi·ªØa c√°c nh√£n n√™n nh∆∞ th·∫ø n√†o?", a: ["C√†ng √≠t c√†ng t·ªët", "Nh√£n nhi·ªÅu nh√£n √≠t", "B·∫±ng nhau", "Kh√¥ng quan tr·ªçng"], c: 2 },
        { q: "Th·ª≠ th√°ch Bias (m·ªùi ng∆∞·ªùi l·∫° qu√©t th·ª≠) gi√∫p ki·ªÉm tra t√≠nh g√¨ c·ªßa d·ªØ li·ªáu?", a: ["ƒê·ªô b·ªÅn m√°y", "T√≠nh ƒëa d·∫°ng", "T·ªëc ƒë·ªô m·∫°ng", "ƒê·ªô s√°ng ƒë√®n"], c: 1 },
        { q: "·∫¢nh c√≥ b√†n tay che m·∫∑t ho·∫∑c v·∫≠t l·∫° che khu·∫•t l√† vi ph·∫°m ti√™u chu·∫©n n√†o?", a: ["ƒê√∫ng (Accuracy)", "ƒê·ªß", "ƒê·∫πp", "L·∫°"], c: 0 },
        { q: "N·∫øu d·ªØ li·ªáu ƒë√£ chu·∫©n m√† m√°y v·∫´n sai, ta c·∫ßn ch·ªânh y·∫øu t·ªë n√†o ·ªü b∆∞·ªõc Train?", a: ["Epochs & Batch size", "Thay Webcam m·ªõi", "X√≥a Form", "T·∫Øt tr√¨nh duy·ªát"], c: 0 }
    ];

    let currentScore = 0;
    let playerRobot;
    let gameArea;
    let qBox;
    let currentQuestionIndex = 0;
    let playerData = []; // L∆∞u l·∫°i d·ªØ li·ªáu ƒë·ªÉ g·ª≠i form
    let gameInterval;
    let dataDropInterval;
    const fallingDataElements = [];

    function startGame() {
        const playerName = document.getElementById('p-name').value;
        const playerClass = document.getElementById('p-class').value;

        if (!playerName || !playerClass) {
            alert("H√£y nh·∫≠p T√™n v√† L·ªõp ƒë·ªÉ b·∫Øt ƒë·∫ßu nhi·ªám v·ª•!");
            return;
        }

        playerData = { name: playerName, class: playerClass };
        document.getElementById('login-screen').style.display = 'none';
        
        playerRobot = document.getElementById('player-robot');
        gameArea = document.getElementById('game-area');
        qBox = document.getElementById('question-box');

        gameArea.addEventListener('mousemove', (e) => {
            let gameAreaRect = gameArea.getBoundingClientRect();
            let newX = e.clientX - gameAreaRect.left - playerRobot.offsetWidth / 2;
            newX = Math.max(0, Math.min(newX, gameAreaRect.width - playerRobot.offsetWidth));
            playerRobot.style.left = newX + 'px';
        });

        loadQuestion();
    }

    function loadQuestion() {
        if (currentQuestionIndex >= questions.length) {
            endGame();
            return;
        }

        qBox.innerText = `QUERY ${currentQuestionIndex + 1}: ${questions[currentQuestionIndex].q}`;
        
        // Clear falling data from previous question
        fallingDataElements.forEach(el => el.remove());
        fallingDataElements.length = 0;
        clearInterval(dataDropInterval);

        dataDropInterval = setInterval(dropData, 1500); // Drop a data box every 1.5 seconds
        gameInterval = setTimeout(nextQuestion, 8000); // Next question after 8 seconds if no answer
    }

    function dropData() {
        const q = questions[currentQuestionIndex];
        const answers = [...q.a]; // Copy array to avoid modifying original
        
        // Randomize the order of answers so correct answer isn't always in same position
        answers.sort(() => Math.random() - 0.5);

        const dataBox = document.createElement('div');
        dataBox.className = 'falling-data';
        dataBox.innerText = answers[0]; // Take the first answer after randomization
        dataBox.dataset.answer = answers[0]; // Store original answer text
        dataBox.dataset.isCorrect = (answers[0] === q.a[q.c]); // Check if it's the correct one

        dataBox.style.left = Math.random() * (gameArea.offsetWidth - dataBox.offsetWidth - 20) + 10 + 'px';
        gameArea.appendChild(dataBox);
        fallingDataElements.push(dataBox);

        let speed = 2; // Initial falling speed
        let fallInterval = setInterval(() => {
            let currentTop = parseInt(dataBox.style.top);
            dataBox.style.top = (currentTop + speed) + 'px';

            // Check for collision
            if (isColliding(playerRobot, dataBox)) {
                handleCollision(dataBox, clearInterval, fallInterval);
                return;
            }

            // If data falls off screen
            if (currentTop > gameArea.offsetHeight) {
                if (dataBox.dataset.isCorrect === 'true') {
                    updateScore(-10, 'miss'); // Missed correct answer
                    playerRobot.classList.add('hit-effect');
                    setTimeout(() => playerRobot.classList.remove('hit-effect'), 300);
                    gameArea.classList.add('screen-shake-anim');
                    setTimeout(() => gameArea.classList.remove('screen-shake-anim'), 200);
                }
                dataBox.remove();
                fallingDataElements.splice(fallingDataElements.indexOf(dataBox), 1);
                clearInterval(fallInterval);
            }
        }, 20);
    }

    function isColliding(elem1, elem2) {
        let rect1 = elem1.getBoundingClientRect();
        let rect2 = elem2.getBoundingClientRect();
        return !(rect1.bottom < rect2.top ||
                 rect1.top > rect2.bottom ||
                 rect1.right < rect2.left ||
                 rect1.left > rect2.right);
    }

    function handleCollision(dataBox, clearIntervalCallback, fallInterval) {
        clearIntervalCallback(fallInterval);
        dataBox.remove();
        fallingDataElements.splice(fallingDataElements.indexOf(dataBox), 1);

        if (dataBox.dataset.isCorrect === 'true') {
            updateScore(20, 'hit');
            confetti({ particleCount: 50, spread: 70, origin: { y: 0.8 } });
            nextQuestion();
        } else {
            updateScore(-15, 'hit');
            gameArea.classList.add('screen-shake-anim');
            setTimeout(() => gameArea.classList.remove('screen-shake-anim'), 200);
            playerRobot.classList.add('hit-effect');
            setTimeout(() => playerRobot.classList.remove('hit-effect'), 300);
        }
    }

    function updateScore(points, type) {
        currentScore += points;
        document.getElementById('current-score').innerText = currentScore;
        
        // Simple visual feedback for score change
        let scoreDisplay = document.getElementById('score-display');
        scoreDisplay.style.transition = 'none';
        scoreDisplay.style.color = (points > 0 ? varToRgb('--success') : varToRgb('--danger'));
        scoreDisplay.style.textShadow = `0 0 10px ${scoreDisplay.style.color}`;
        setTimeout(() => {
            scoreDisplay.style.transition = 'color 0.5s, text-shadow 0.5s';
            scoreDisplay.style.color = varToRgb('--main');
            scoreDisplay.style.textShadow = `0 0 5px ${varToRgb('--main')}`;
        }, 200);
    }

    function nextQuestion() {
        clearTimeout(gameInterval);
        clearInterval(dataDropInterval);
        fallingDataElements.forEach(el => el.remove()); // Remove all falling data
        fallingDataElements.length = 0; // Clear array
        currentQuestionIndex++;
        setTimeout(loadQuestion, 1000); // Small delay before next question
    }

    function endGame() {
        document.getElementById('game-area').removeEventListener('mousemove', (e) => {
            // Remove the mousemove listener
        }); 
        clearInterval(dataDropInterval);
        clearTimeout(gameInterval);
        fallingDataElements.forEach(el => el.remove()); // Clean up any remaining falling data

        document.getElementById('final-screen').style.display = 'flex';
        document.getElementById('final-score').innerText = currentScore + " ƒêI·ªÇM";
        document.getElementById('final-message').innerText = `Ch√∫c m·ª´ng ${playerData.name} (${playerData.class}) ƒë√£ ho√†n th√†nh nhi·ªám v·ª•!`;

        let rankText = "";
        if (currentScore >= 160) { rankText = "RANK: K·ª∏ S∆Ø D·ªÆ LI·ªÜU T·ªêI CAO üëë"; }
        else if (currentScore >= 120) { rankText = "RANK: CHUY√äN VI√äN PH√ÇN T√çCH üöÄ"; }
        else { rankText = "RANK: TH·ª∞C T·∫¨P SINH D·ªÆ LI·ªÜU üõ†Ô∏è"; }
        document.getElementById('final-rank').innerText = rankText;

        // G·ª≠i d·ªØ li·ªáu ng·∫ßm v·ªÅ Google Form
        const form = document.createElement('form');
        form.method = 'POST';
        form.action = CONFIG_FORM.formAction;
        form.target = 'hidden_iframe';

        const dataToSend = {
            [CONFIG_FORM.entryName]: playerData.name,
            [CONFIG_FORM.entryClass]: playerData.class,
            [CONFIG_FORM.entryScore]: currentScore
        };

        for (const key in dataToSend) {
            const input = document.createElement('input');
            input.type = 'hidden';
            input.name = key;
            input.value = dataToSend[key];
            form.appendChild(input);
        }
        document.body.appendChild(form);
        form.submit();
    }

    // Helper to get RGB value from CSS variable (for dynamic text shadow)
    function varToRgb(variable) {
        const tempDiv = document.createElement('div');
        tempDiv.style.color = getComputedStyle(document.documentElement).getPropertyValue(variable);
        document.body.appendChild(tempDiv);
        const color = getComputedStyle(tempDiv).color;
        tempDiv.remove();
        return color;
    }

    document.addEventListener('DOMContentLoaded', () => {
        // Hide default mouse cursor
        document.body.style.cursor = 'none'; 
        // Attach event listener only after game starts
        gameArea.style.cursor = 'none'; // Hide cursor over game area
    });

</script>
</body>
</html>
